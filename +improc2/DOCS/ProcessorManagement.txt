
** Processor Management **

Running a processor (a postprocessor or a multi-channel processor being special kinds of processors) can require data stored in other processor objects.

Goals of processor management:

1. Provide an official container that can keep a bunch of processors.

2. The manager should sense when the data in any of its processors has changed and flag all dependent processors as needing an update. 

3. The manager should be smart enough to supply all processors necessary to run a dependent processor.


** Types of Data in a Processor **

With regards to the need for updating dependent processors there are the following kinds of data in a processor:

* Processor running parameters. For example, the filter parameters used when doing an aTrousRegionalMax spot finding. 

	User Experience: These can only be set at the moment the processor is first instantiated and cannot be modified thereafter. 

	Developer Strategy: You should ensure that these parameters can only be set by arguments to the processor constructor.

* Intermediate data that cannot change after processor is run. For example, the list of regional maxima and their positions in an aTrousRegionalMax processor, or the stored dapi max-merge in a dapiProc processor. 

	User Experience: You have no way to modify this data.

	Developer Strategy: These data's SetAccess attributes should be protected or private.

* Dependent (not-stored) data: These are calculated on the fly based on data existing in the processor, and can never be set. For example, the number of RNA spots in a RegionalMaxProc is a dependent property, calculated on-the-fly based on the list of regional maxes and the threshold.

* User-adjustable data: Typically something like a stringency parameter that the user can adjust. The threshold in RegionalMaxProc or the allowed spot-size range in a spot-fitting processor are classic examples.

	User Experience: You can modify these, and it will affect the results of dependent properties.

	Developer Strategy: You must ensure that any facilities you give the user to set these will automatically flag the 

** Single Channel Processor Queue **

For the processors that deal with data only from a single channel, we have implemented them as a queue.


** Requirements of compatible processors/postprocessors **

Should be runnable with exactly two arguments: an image object and a channelName. i.e. runProcessor must be able to accept a call like:

proc.runProcessor( imageObj, channelName )

For single channel PostProcessors, all acceptable calls to runProcessor must begin with the dependent processors in the order that they appear in the postprocessor's 'procsIDependOn' property. In particular, the following must be an acceptable call if proc.procsIDependOn = {'class1','class2','class3'}:

proc.runProcessor( proc1, proc2, proc3, imageObj, channelName )

but other calls of the form:

proc.runProcessor( proc1, proc2, proc3, varargin )

may be acceptable too.